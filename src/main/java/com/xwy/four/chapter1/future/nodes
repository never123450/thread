实现思路
每个Worker线程都维护-个任务队列，即ForkJoinWorkerThread中的任务队列
〉任务队列是双向队列， 这样可以同时实现LIFO和FIFO
子任务会被加入到原先任务所在Worker线程的任务队列
◆Worker线 程用LIFO的方法取出任务，后进队列的任务先取出来(子任务总是后加入队列，但是
需要先执行)
当任务队列为空，会随机从其他的worker的队列中拿走一个任务执行(工作窃取: steal work)
〉如果一个Worker线程遇 到了join操作，而这时候正在处理其他任务,会等到这个任务结束。否则
直接返回
如果一个Worker线程窃取任务失败，它会用yield或者sleep之类的方法休息一会儿，再尝试(如
果所有线程都是空闲状态，即没有任务运行，那么该线程也会进入阻塞状态等待新任务的到来)


适用
使用尽可能少的线程池-在大多数情况下，最好的决定是为每个应用程序或系统使用一-个线程池
如果不需要特定调整，请使用默认的公共线程池
使用合理的阈值将ForkJoinTask拆分为子任务
避免在ForkJoinTask中出现任何阻塞
适合数据处理、结果汇总、统计等场景;
java8实例: java.util.Arrays类用于 其parallelSort()方法

结语：工作窃取带来的性能提升偏理论，API的复杂性高，实际研发中可控性来说不如其他的API

总的执行时间，取决于执行最慢的逻辑。
逻辑之间无依赖关系，可同时执行，则可以应用多线程技术进行优化。

线程安全性级别
《Effective Java》- Joshua J. Bloch提到，工具类需要显示的说明它的安全性级别:
1.不可变的--这个类的实例是不可变的。 这样的例子包括String, Long, Biglnteger。
2.无条件的线程安全--这 个类的实例是可变的，但是这个类有足够的内部同步。例子包括Random,
ConcurrentHashMap。
3.有条件的线程安全--除 了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件
安全相同。例子包括: Collections.synchronized包装返回的集合，它们的迭代器要求外部同步。
4.非线程安全--这 个类的实例是可变的。为了并发使用它们，客户必须利用自己选择的外部同步包围每个方法
调用。例子包括ArrayList
5.线程对立的一-一 这个类不能安全地被多个线程并发使用，即使所有的方法调用都被外围同步包围。
