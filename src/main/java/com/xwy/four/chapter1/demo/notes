stop：终止线程，并且清除监控器锁的信息，但是可能导致线程安全问题，JDK不建议使用
Destroy：JDK未实现该方法

CPU性能优化手段-缓存
为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。
例如：CPU高速缓存。尽可能地避免处理器访问主内存的时间开心，处理器大多会利用缓存（cache）以提高性能

多级缓存
L1 cache（一级缓存）是CPU第一次高速缓存，氛围数据缓存和指令缓存。一般服务器CPU的L1缓存的容量通常在32-4096KB
L2 cache 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部防止一高速存储器，即二级缓存
L3 现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。
具有较大L3缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。一般多核共享一个L3缓存

CPU在读取数据时，先在L1中寻找，再从L2寻找，再从L3寻找，然后是内存，在后是外存储器

多CPU读取同样的数据进行缓存，进行不同运算之后，最终写入主内存以哪个CPU为准?
在这种高速缓存回写的场景下，有一个缓存-致性协议多数CPU厂商对它进行了实现。
MESI协议，它规定每条缓存有个状态位，同时定义了下面四个状态:
修改态(Modified) - 此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有;
专有态(Exclusive) -此cache行内容同于主存，但不出现于其它cache中;
共享态(Shared) -此cache行内容同于主存，但也出现于其它cache中;
无效态(Invalid) - -此cache行内容无效(空行)。
多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其他CPU。
也就是意味着，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证最终一致


CPU性能优化手段-运行时指令重排

//正常执行的三步骤
//重排序后执行

指令重排的场景:当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能,可能将后面的读缓存命令优先执行。
并非随便重排，需要遵守as-if-serial语义
as-if-serial语义的意思指:不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)
程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。
也就是说:编译器和处理器不会对存在数据依赖关系的操作做重排序。


内存屏障
处理器提供了两个内存屏障指令(Memory Barrier)用于解决上述两个问题:
写内存屏障(Store Memory Barrier) :在指令后插入Store Barrier,能让写入缓存中的最新
数据更新写入主内存，让其他线程可见。
强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。
读内存屏障(Load Memory Barrier) :在指令前插入Load Barrier,可以让高速缓存中的数据失效，强制从新主内存加载数据。
强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题

结语
这个章节是后面JVM线程安全问题的铺垫。
同时，也看到了现代CPU不断演进，在程序运行优化中做出的努力。
不同CPU厂商所付出的人力物力成本，最终体现在不同CPU性能差距.上。


通信的方式
要想实现多个线程之间的协同，如:线程执行先后顺序、获取某个线程执行的结果等等。
涉及到线程之间相互通信，分为下面四类:
1)文件共享
2)网络共享
3)共享变量.
4)jdk提供的线程协调API
细分为: suspend/resume、 wait/notify、 park/unpark
本章节代码示例: Demo6.java

wait/notify机制
这些方法只能由同一对象锁的持有者线程调用，也就是写在同步块里面，否则会抛出IllegalMonitorStateException异常。
wait方法导致当前线程等待，加入该对象的等待集合中，并且放弃当前持有的对象锁。
notify/notifyAll方法唤醒-个或所有正在等待这个对象锁的线程。
注意:虽然会wait自动解锁，但是对顺序有要求，如果在notify被调用之后， 才开始wait方法的调用，线程会永远处于WAITING状态。

park/unpark机制
Demo8。线程调用park则等待“许可” ，unpark方法为指定线程提供‘“许可(permit)” 。
不要求park和unpark方法的调用顺序。
多次调用unpark之后，再调用park,线程会直接运行。
但不会叠加，也就是说，连续多次调用park方法，第一-次会拿到“许可”直接运行，后续调用会进入等待。


伪唤醒
警告!之前代码中用if语句来判断，是否进入等待状态，是错误的!
官方建议应该在循环中检查等待条件，原因是处于等待状态的线程可能会收到错误警报和伪唤醒，
如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。
伪唤醒是指线程并非因为notify、notifyall、 unpark等 api调用而唤醒，是更底层原因导致的。


JAVA中锁的概念
自旋锁:为了不放弃CPU执行事件，循环的使用CAS技术对数据尝试进行更新，直至成功。
悲观锁:假定会发生并发冲突，同步所有对数据的相关操作，从读数据就开始上锁。
乐观锁:假定没有冲突，在修改数据时如果发现数据和之前获取的不-致，则读最新数据，修改后重试修改。
独享锁(写):给资源加上写锁，线程可以修改资源，其他线程不能再加锁; (单写)
共享锁(读):给资源加上读锁后只能读不能改，其他线程也只能加读锁，不能加写锁; (多读)
可重入锁、不可重入锁:线程拿到一把锁之后，可以自由进入同- -把锁所同步的其他代码。
公平锁、非公平锁:争抢锁的顺序，如果是按先来后到，则为公平。
几种重要的锁实现方式: synchronized、ReentrantLock、ReentrantReadWrite lock



同步关键字synchronized
属于最基本的线程通信机制，基于对象监视器实现的。
Java中的每个对象都与一个监视器相关联，一个线程可以锁定或解锁。
一次只有一个线程可以锁定监视器。
试图锁定该监视器的任何其他线程都会被阻塞，直到它们可以获得该监视器上的锁定为止。
特性:可重入、独享、悲观锁
锁的范围:类锁、对象锁、锁消除、锁粗化
提示:同步关键字，不仅是实现同步，根据JMM规定还能保证可见性(读取最新主内存数据，结束后写入主内存)。

重量级锁-监视器(monitor)
修改mark word如果失败，会自旋CAS一定次数，该次数可以通过参数配置:
超过次数，仍未抢到锁，则锁升级为重量级锁，进入阻塞。
monitor也叫做管程,计算机操作系统原理中有提及类似概念。-个对象会有-一个对应的monitor。




